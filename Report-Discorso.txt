Buongiorno, abbiamo scelto di presentare il progetto sul raffinamento complesso.Partiamo inanzittuo sul descrivere qual è il problema:il raffinamento complesso è utilizzato in diversi ambiti, primo fra tutti quello della risoluzione di problemi differenziali. Esso permette di ottenere risultati precisi e di qualità riducendo il margine di errore.
Descrizione del Problema
Abbiamo in input 3 file csv relativi ai vertici, lati e triangolo. Verrano implementati comr classi denominate Cell0D,Cell1D,Cell2D. Gli attributi per ognuna di esse sono: Marker, id, coord per Cell0D, marker id e vertici per Cell1D, id vertici e lati per Cell2D. Per quanto riguarda i metodi abbiamo: lengthedge per il calcolo della lunghezza del lato, maxedge per la ricerca del lato più lungo e area per il calcolo dell'area del triangolo(Vedi file UMl). Sfruttando la formula della distanza geometrica usiamo la funzione che prende in input il vettore dei punti. Per il calcolo del maxedge prendiamo in input il vettore dei punti e quello dei segmenti, confrontando i vari lati. Per il calcolo dell'area abbiamo utilizzato la formula di Gauss salvando in un vettore vectT gli id dei triangolo relative alle aree calcolate. Abbiamo inziato con l'importare le mesh iniziali qui rappresentate, attraverso 3 funzioni di import. Per ordinare i triangoli per area decrescente abbiamo utilizzato l'algortimo di HeapSort. La scelta di questo algoritmo consente di ottenere un ordinamento efficiente operando in loco poichè non fa uso di memoria aggiuntivas, al di là di un numero costante di variabili ausiliarie. Il suo costo computazionale è quello ottimale e vale O(nlogn). Abbiamo creato due funzioni(makeheap e heapsort).La prima funzione la abbiamo utilizata per creare l'heap e poi abbiamo fatto il sorting. Abbiamo utilizzato il template perchè è conveniente usarla nei test. 
Abbiamo definito una matrice di adiacenza 2xN che ci permettesse di visualizzare per ogni triangolo l'id del triangolo adiacente, attraverso l'utilizzo del lato.
All'interno del cpp procediamo con l'implementazione delle funzioni Bisect e Propagazione, per poi ottenere come export i file csv aggiornati. Se nel controllo iniziale del marker esso risulta diverso da zero, il che significa che il triangolo si trova al bordo della mesh e verrà effettuata solo la bisezione.   
Nella funzione di bisezione abbiamo iniziato cercando il lato più lungo del triangolo,definito come longest, che abbiamo trovato con il metodo maxedge. Trovato il lato maggiore, definiamo il suo punto medio indicato con NewVertex e il suo opposto Opposite.
L'idea é quella di definire la mediana mediante i punti sopra definiti. (il punto medio verrà inserito nel vettore di vertici). Effettuata la bisezione del triangolo abbiamo così ottenuto due triangoli: uno con l'id del triangolo originale (triaggiornato), l'altro con un nuovo id(NewTri). Questo sarà il procedimento generale che useremo durante l'implementazione della funzione di propagazione.
Per mantenere la mesh ammissibile , se il triangolo non si trova al bordo , è necessario raffinare anche il triangolo adiacente rispetto al lato bisezionato del triangolo appena raffinato.
Distinguiamo ora due diverse casistiche : 
_ 1 in cui il triangolo adiacente ha come lato più lungo il lato precedentemente bisezionato
_2 in cui il triangolo adiacente ha come lato più lungo un lato diverso da quello precedentemente bisezionato.
CASO 1
Per quanto concerne il primo caso, colleghiamo direttamente il punto medio del lato di adiacenza, quello più lungo, al vertice opposto (newOpposite), definendo il segmento unione.
Anche in questo caso , dal triangolo di partenza si vanno così a creare i due triangoli Triangolo, UltimoTriangolo.
CASO 2 
Per quanto riguarda il secondo caso , abbiamo effettuato una distinzione in base alla posizione del lato più lungo.
Esso infatti può trovarsi o a sinistra , se l'origine del lato max coincide con l'origine del vecchio lato massimo(idlatotagliatovecchio), oppure a destra, se l'origine del nuovo lato lungo coincide con l'end del vecchio. In entrambe le casistiche effettuiamo nuovamente la bisezione. Otteniamo ancora una volta due nuovi triangoli, che andremo a rinominare(sempre nuovo e aggiornato). Questo nuovo lato lo abbiamo chiamato MedianaPropa, definita mediante i due punti NewVertexPropa e OppistePropa, ottenendo cosi 2 triangoli chiamati NewTriPropa e TriPropaAggiornato). Sorge il problema dell'ammissibilità per cui effettuiamo un nuovo collegamento tra NewVertexPropa e NewVertex creando cosi un nuovo segmento chiamata Unione. I traingoli ottenuti alla fine sono: Residuo, penultimo e aggiornato.
Questo processo va iterato per i triangoli selezionati, cioè quelli con area minore della tolleranza, richiamando ricorsivamente la funzione propagazione.
Aprendo una piccola parentesi sulla tolleranza, abbiamo usato due diversi tipi di tolleranza per quanto riguarda il calcolo delle lunghezze dei lati e per il calcolo delle aree.
Combinando static e constexpr, è possibile dichiarare un valore costante associato a una classe o a una funzione e valutato durante la compilazione. Questo può fornire vantaggi in termini di prestazioni evitando calcoli durante l'esecuzione e consentendo al compilatore di ottimizzare il codice.
Come ultima cosa per il cpp abbiamo utilizzato 3 funzioni per esportare vertici, lati e triangoli per avere la mesh raffinata.

